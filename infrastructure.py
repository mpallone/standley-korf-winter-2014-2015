#!/usr/bin/env python3 
"""Gridworld infrastructure.""" 

import logging 
import random 
import enum 

from collections import namedtuple 

Coordinate = namedtuple("Coordinate", "x y")

class GridWorldEnum(enum.Enum):
    empty = "empty" 
    obstacle = "obstacle" 

class GridWorldAgent: 
    """An agent in a grid world."""

    def __init__(self, goal_x, goal_y, assigned_x, assigned_y, id):
        """Create a GridWorldAgent object.

        @param goal_x: destination x coordinate (an integer)
        @param goal_y: destination y coordinate (an integer) 
        @param assigned_x: new x coordinate for next timestep (an integer)
        @param assigned_y: new y coordinate for next timestep (an integer)
        @param id: a positive integer
        """
        self.goal = Coordinate(goal_x, goal_y)
        self.assignment = Coordinate(assigned_x, assigned_y)
        assert id > 0 # 0 is reserved
        self.id = id 

    def __eq__(self, other): 
        return self.goal.x == other.goal.x and \
               self.goal.y == other.goal.y and \
               self.assignment.x == other.assignment.x and \
               self.assignment.y == other.assignment. y and \
               self.id == other.id 

    def __hash__(self): 
        """Does this really need a docstring?""" 
        myHash = 0 
        for c in str(self): 
            myHash = 101 * myHash + ord(c)
        return myHash 

    def __str__(self):
        """Every agent has a UNIQUE string to facilitate building hashes."""
        myString = ""
        myString += "id="
        myString += str(self.id)        
        myString += " g="
        myString += str(self.goal.x)
        myString += str(self.goal.y)        
        myString += " a="
        myString += str(self.assignment.x)
        myString += str(self.assignment.y)          
        return myString

    def deepcopy(self): 
        return GridWorldAgent(self.goal.x, self.goal.y,
                              self.assignment.x, self.assignment.y, self.id)

def getLengthAndWidth(cpfGrid): 
    """Return the length and width of cpfGrid."""
    length = len(cpfGrid)
    width = 0 
    if length > 0: 
        width = len(cpfGrid[0]) 
    return length, width     

def generateSuccessorCells(coordinate, cpfGrid): 
    """Return a list of coordinates/tuples representing plausible (although not
    necessarily legal!) moves. 
    """
    length, width = getLengthAndWidth(cpfGrid)
    moves = []

    x = coordinate.x 
    y = coordinate.y 
    for potential_x in range(x-1, x+1+1): 
        for potential_y in range(y-1, y+1+1): 
            if potential_x >= 0 and potential_x < width and                   \
               potential_y >= 0 and potential_y < length:
                if cpfGrid[potential_x][potential_y] != GridWorldEnum.obstacle:
                    moves.append(Coordinate(potential_x, potential_y))
    return moves 

def isConnected(cpfGrid): 
    """Determine if cpfGrid is connected. 

    "Connected" means that any empty cell can be reached by any other empty 
    cell. 

    @param cpfGrid: a grid similar to what's generated by generateCpfGrid.
    @return True if cpfGrid is connected, and False otherwise. 
    """
    length, width = getLengthAndWidth(cpfGrid)     

    # Make a deep copy of the grid for us to manipulate. 
    deepCopy = []
    for rowIndex in range(length):
        deepCopy.append([])
        for columnIndex in range(width): 
            item = cpfGrid[rowIndex][columnIndex]
            deepCopy[rowIndex].append(item)

    # Start with a node that doesn't have an obstacle. 
    startingNode = Coordinate(0, 0) 
    num_obstacles = 0 
    for rowIndex in range(length):
        for columnIndex in range(width): 
            thisCell = deepCopy[rowIndex][columnIndex]
            if thisCell == GridWorldEnum.obstacle:
                num_obstacles += 1
            else: 
                startingNode = Coordinate(rowIndex, columnIndex)
                break 
    if num_obstacles == length * width: 
        return False # Every cell is an obstacle! 

    # Do a breadth first search, marking nodes we can reach. 
    openList = generateSuccessorCells(startingNode, cpfGrid)
    while len(openList) > 0: 
        currNode = openList.pop(0)
        if deepCopy[currNode.x][currNode.y] != "visited": 
            deepCopy[currNode.x][currNode.y] = "visited" 
            openList.extend(generateSuccessorCells(currNode, cpfGrid))

    # The grid is connected if every node has been marked, or is an obstacle. 
    for rowIndex in range(length):
        for columnIndex in range(width): 
            if deepCopy[rowIndex][columnIndex] == GridWorldEnum.empty:
                return False 
    return True 


def convertGridToString(cpfGrid): 
    """Return a string representation of the cpfGrid that human beings can 
    easily understand."""
    length, width = getLengthAndWidth(cpfGrid)
    representation = ""
    for rowIndex in range(width):
        for columnIndex in range(length): 
            item = cpfGrid[rowIndex][columnIndex]
            if item == GridWorldEnum.empty: 
                representation += "."
            elif item == GridWorldEnum.obstacle:
                representation += "x" 
            else:
                representation += "?"
        representation += "\n"
    return representation


def generateCpfGrid(length=8, width=8, obstacle_probability=0.15): 
    """Return a grid that may or may not be connected. 

    Obstacles will be represented by GridWorldEnum.obstacle. Empty spaces will 
    contain GridWorldEnum.empty. "Connected" means that any empty cell can be
    reached from any other empty cell. 

    @param length: the length of the grid (default: 8)
    @param width: the width of the grid (default: 8)
    @param obstacle_probability: the probability that a cell will be an 
        obstacle (default: 0.15). 
    @return a grid (2d list) composed of GridWorldEnum.empty and 
        GridWorldEnum.obstacle values.     
    """
    cpfGrid =[[] for _ in range(length)]
    for rowIndex in range(length):
        for columnIndex in range(width): 
            cpfGrid[rowIndex].append(GridWorldEnum.empty)
            if random.random() < obstacle_probability:
                cpfGrid[rowIndex][columnIndex] = GridWorldEnum.obstacle
    return cpfGrid

def generateConnectedCpfGrid(length=8, width=8, obstacle_probability=0.15):
    """Return a connected grid for cooperative pathfinding problems. 

    Obstacles will be represented by GridWorldEnum.obstacle. Empty spaces will 
    contain " ". "Connected" means that any empty cell can be reached from any
    other empty cell. 

    @param length: the length of the grid (default: 8)
    @param width: the width of the grid (default: 8)
    @param obstacle_probability: the probability that a cell will be an 
        obstacle (default: 0.15). 
    @return a connected grid (2d list) composed of GridWorldEnum.empty and 
        GridWorldEnum.obstacle values. 
    """
    if obstacle_probability >= 0.7: 
        logging.warning("High obstacle probability in generateConnectedCpfGrid"
                        "; it may take a somewhat long time to generate a "
                        "connected grid. [" + str(obstacle_probability) + "]")

    grid = generateCpfGrid(length, width, obstacle_probability)
    while not isConnected(grid): 
        grid = generateCpfGrid(length, width, obstacle_probability)
    return grid 

if __name__ == "__main__": 
    grid = generateConnectedCpfGrid(obstacle_probability = 0.5)
    print(convertGridToString(grid))
    agent = GridWorldAgent(0, 1, 2, 3, 4, 5)
    print(agent.__hash__())